Oracle提供了五种索引扫描类型，根据具体索引类型、数据分布、约束条件以及where限制的不同进行选择： 
索引唯一扫描(index unique scan)
索引范围扫描(index range scan)
索引跳跃扫描(index skip scan)
索引全扫描(index full scan)
索引快速扫描(index fast full scan)

2、索引唯一扫描(index unique scan) 
1. 索引唯一扫描，仅仅针对唯一索引的扫描，且仅适用于等值（=）条件的查询。从结果集看，至多返回一条记录。
具体情况分析：
2. 对于单一列建立的索引（单一索引），当索引属于唯一索引，在检索条件中，使用该索引进行检索，且检索值不是null时，会使用“索引唯一扫描”
3. 对于单一列建立的索引（单一索引），当索引属于唯一索引，在检索条件中，使用该索引进行检索，且检索值等于null时，会使用“全表扫描”
4. 对于多个列建立的索引（组合索引），当索引属于唯一索引，且检索条件中，使用该组合索引进行检索，且检索列使用组合索引涉及的所有列时，会使用“索引唯一扫描”

3、索引范围扫描(index range scan)
索引范围扫描，不仅可以针对唯一索引，也可以针对非唯一索引。从结果集看，可以是一条记录，也可以是多条记录。
1. 对于单一列建立的索引（单一索引），当索引属于唯一索引，在检索条件中，使用该索引进行检索，且使用范围的操作符（>,<,>=,<=,between），会使用“索引范围扫描”。
2. 对于单一列建立的索引（单一索引），当索引属于非唯一索引，在检索条件中，使用该索引进行检索，且检索值不是null值，会使用“索引范围扫描”。
3. 对于多个列建立的索引（组合索引），当索引属于唯一索引，在检索条件中，使用该索引进行检索，且检索列使用组合索引涉及的部分列，但必须存在组合索引的引导列（创建组合索引时指定的第一列）时，会使用“索引范围扫描”。
4. 对于多个列建立的索引（组合索引），当索引属于非唯一索引，在检索条件中，使用该索引进行检索，检索列涉及组合索引的部分列或者全部列，但必须存在组合索引的引导列（创建组合索引时指定的第一列）时，会使用“索引范围扫描”。

4、索引跳跃扫描（index skip scan）
该索引扫描方式主要发生在组合索引上，且组合索引的引导列未被指定在检索条件中的情况下发生。在组合索引中，无论该索引是否为唯一索引。当引导列未被指定在检索条件的情况下，可能会发生“索引跳跃扫描”
1. 对于组合索引，在无前导列的情况下还能使用索引，是因为Oracle帮我们对该索引的前导列的所有distinct值做了遍历。
2. 所谓的对目标索引的所有distinct值做遍历，其实际含义相当于对原目标SQL做等价改写（即把要用的目标索引的所有前导列的distinct值都加进来）。

例如：create index idx_employee on employee(gender,employee_id)，表数据量10000行，其中gender列只有“M”跟“F”值。
当执行select * from employee where employee_id = 100时，相当于执行了等价改写，改写为：
select * from employee where gender = 'F' and employee_id = 100 
union all 
select * from employee where gender = 'M' and employee_id = 100;

因此，Oracle中的索引跳跃式扫描仅仅适用于那些目标索引前导列的distinct值数量较少、后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率一定会随着目标索引前导列的distinct值数量的递增而递减。否则将执行全表扫描。

--收集测试表最新的统计信息
Yumiko@Sunny >analyze table test compute statistics for table for all columns for all indexes;
Table analyzed.

--清空buffer cache缓冲池，保证无测试表的数据块存在在内存中，防止影响到测试结果
Yumiko@Sunny >alter system flush buffer_cache;
System altered.

5、索引全扫描（index full scan）
对于索引全扫描，就是使用目标索引进行索引扫描时，会扫描所有索引叶块的所有索引行。

对于索引全扫描，只适用于CBO。

对于索引全扫描，使用单块读取的方式，有序读取索引块。

对于索引全扫描，从结果集看，结果全部源于索引块，而且由于已经按照索引键值顺序排序，因此不需要单独排序

对于索引全扫描，会话会产生db file sequential reads事件。

 

具体情况分析：

对于单一列建立的索引（单一索引），当该索引列有非空约束时，在具体检索中只检索该列全部数据，会使用“索引全扫描”。
对于单一列建立的索引（单一索引），当该索引列无非空约束时，在具体检索中只检索该列全部数据，且是对该列的统计（count）或者非空条件查询（is not null），会使用“索引全扫描”。
对于单一列建立的索引（单一索引），当该索引列无非空约束时，在具体检索中只检索该列全部数据，且是对该列的常规查询，不会使用“索引全扫描”。（这是因为对于oracle索引，对于列中存在的null值不记录在b-tree索引中）
对于多个列建立的索引（组合索引），当该索引列有非空约束时，在具体检索中只检索组合索引中涉及的全部列或者部分列的全部数据，会使用“索引全扫描”。
对于多个列建立的索引（组合索引），当该索引列无非空约束时，在具体检索中只检索组合索引中涉及的全部列或者部分列的全部数据，且是对这些相关列的统计（count）或者非空条件查询（is not null），会使用“索引全扫描”。
对于多个列建立的索引（组合索引），当该索引列无非空约束时，在具体检索中只检索组合索引中涉及的全部列或者部分列的全部数据，且是对该列的常规查询，不会使用“索引全扫描”。
